PACKET FILTER GENERATOR

This tool is for generating packet filtering rules from a fairly high-
level description language.  It doesn't support all of the whizz-bang
features of the latest and greatest packet filters, but supports a
decent subset which is sufficient for me.

The syntax looks not entirely unlike that of "fk"s ACL facility, and
it might be worth familiarising yourself with that first (not least
because it is a lot less experimental).

An example will probably show most of the basics.  Here's a simple one
for a single-interface host (perhaps a mail server):

	# Unfortunately, we don't have time to audit the
	# communications which go on locally
	{input lo; output lo} accept;

	# But we want to be a bit more careful when speaking
	# to the outside world
	input eth0 {
		proto tcp {
			dport { smtp pop-3 } accept;
			dport ssh source ournet/24 accept;
			# We don't answer this, but don't want to
			# cause timeouts by blocking it
			dport auth reject;
			drop;
		};
		# We don't run any UDP (or other non-TCP)
		# services
		drop;
	};
	output eth0 {
		proto tcp {
			dport { smtp auth } accept;
			drop;
		};
		# Outbound DNS is OK
		proto udp dport domain dest { ns0 ns1 } accept;
		drop;
	};


At first sight, this might not look like much more than a shorthand
for raw packet filtering rules, and indeed it isn't.  However, the
abbreviation is better than one might imagine because it also (again,
as far as the underlying packet filter allows it) outputs appropriate
rules for returning packets on a connection, and applies stateful
rules where possible.

So a simple rule like:

	output eth0 proto tcp dport http accept;

might generate ipchains rules like:

	ipchains -A output -i eth0 -p tcp --dport http -j ACCEPT
	ipchains -A input -i eth0 -p tcp --sport http ! --syn -j ACCEPT

to give simple "state" matching -- the second rule will block any
packets which could initiate a connection.  Otherwise, an attacker
could connect to any port on your machine merely by binding the
attack program to port 80 on his machine.

The same rule might generate these iptable rules as below:

	iptables -A output -o eth0 -p tcp --dport=http 		\
		-m state --state=NEW,ESTABLISHED -j ACCEPT
	iptables -A input -i eth0 -p tcp --sport=http ! --syn	\
		-m state --state=ESTABLISHED -j ACCEPT

Note the explicit state checking here (which, in theory, makes the
"! --syn" bit unnecessary, but a bit of defence in depth never hurt).


SIGNIFICANT DIFFERENCES FROM ACL SYNTAX

There are a number of places where the filter language differs from
the ACL language.  They are not (well, not all) as gratuitous as one
might think at first.

 * ACL has "allow" and "deny", filter has "accept", "drop"
   and "reject".

 * ACL makes no distinction between the actual inbound and
   outbound connections which make up a proxied logical
   connection.

These are essentially because a packet filter isn't really in a position
to permit or refuse a connection -- it acts only on single packets,
and is not really able to reason about connections (whatever the blurb
claims).  It also matches the terminology used by Linux's iptables.

$Id: README,v 1.1 2001/09/25 17:22:39 matthew Exp $
